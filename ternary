function ternarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        // Divide o intervalo em 3 partes
        let mid1 = left + Math.floor((right - left) / 3);
        let mid2 = right - Math.floor((right - left) / 3);

        // Verifica se o alvo estÃ¡ em uma das duas posiÃ§Ãµes intermediÃ¡rias
        if (arr[mid1] === target) {
            return mid1;
        }
        if (arr[mid2] === target) {
            return mid2;
        }

        // Ajusta os limites de busca dependendo da comparaÃ§Ã£o
        if (target < arr[mid1]) {
            right = mid1 - 1; // Ajusta a busca para a primeira parte
        } else if (target > arr[mid2]) {
            left = mid2 + 1; // Ajusta a busca para a Ãºltima parte
        } else {
            left = mid1 + 1; // Ajusta a busca para a parte do meio
            right = mid2 - 1;
        }
    }

    return -1; // Elemento nÃ£o encontrado
}

const arr = [1, 3, 4, 6, 8, 12, 15, 18, 21, 25, 30];

console.log(ternarySearch(arr, 15)); // SaÃ­da: 6
console.log(ternarySearch(arr, 100)); // SaÃ­da: -1

// AnÃ¡lise de Desempenho
Ternary Search:
O Ternary Search divide a lista em trÃªs partes a cada iteraÃ§Ã£o. Isso pode ser mais vantajoso em certos cenÃ¡rios onde o nÃºmero de comparaÃ§Ãµes pode ser menor para listas muito especÃ­ficas, mas, em termos gerais, a complexidade de tempo permanece 
ğ‘‚ que Ã© mais lento que o Binary Search
â€‹n) devido Ã  maior quantidade de comparaÃ§Ãµes em cada iteraÃ§Ã£o.
Binary Search:
O Binary Search Ã© mais eficiente em termos de nÃºmero de comparaÃ§Ãµes, pois divide a lista em duas partes a cada iteraÃ§Ã£o, o que resulta em uma complexidade de 
 n). Para listas grandes, o Binary Search tende a ser mais rÃ¡pido devido Ã  sua menor quantidade de comparaÃ§Ãµes por iteraÃ§Ã£o.
