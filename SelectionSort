function selectionSort(arr) {
    const steps = [];
    const n = arr.length;

    for (let i = 0; i < n - 1; i++) {
        let minIndex = i;

        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }

        if (minIndex !== i) {
            [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
        }

        steps.push([...arr]);
    }

    return steps;
}

const numbers = [64, 34, 25, 12, 22, 11, 90];
const steps = selectionSort(numbers);

steps.forEach((step, index) => {
    console.log(`Itera√ß√£o ${index + 1}:`, step);
});

/////////////////
An√°lise de Desempenho
Listas Pequenas:

O Selection Sort √© eficiente e f√°cil de implementar.
O tempo de execu√ß√£o n√£o √© um problema significativo para listas pequenas (ex.: menos de 100 elementos).
Listas M√©dias:

O algoritmo continua funcional, mas sua complexidade 
ùëÇ(ùëõ2)O(n 2) come√ßa a impactar o desempenho em listas maiores (ex.: 1.000 a 10.000 elementos).
Listas Grandes:

Para listas muito grandes (ex.: 100.000+ elementos), o Selection Sort √© significativamente mais lento comparado a algoritmos mais eficientes, como Merge Sort ou Quick Sort.
Ele faz muitas compara√ß√µes mesmo quando os elementos j√° est√£o parcialmente ordenados.

